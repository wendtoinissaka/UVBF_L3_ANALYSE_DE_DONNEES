print("Confusion Matrix for Logistic Regression")   # Affiche un message pour indiquer que la matrice de confusion sera affichée
table(testing$Exited, fitted.results > 0.5)    # Crée une table croisée pour montrer les résultats réels vs prédits
# # 'httr' : Pour faire des requêtes HTTP et interagir avec des API.
# install.packages("httr")
#
# # 'cowplot' : Pour combiner plusieurs graphiques ggplot2 en un seul.
# install.packages("cowplot")
#
# # 'dplyr' : Pour manipuler et transformer des données facilement.
# install.packages("dplyr")
#
# # 'ggpubr' : Pour rendre les graphiques ggplot2 plus présentables.
# install.packages("ggpubr")
#
# # 'ggplot2' : Pour créer des graphiques de qualité en R.
# install.packages("ggplot2")
#
# # 'FactoMineR' : Pour l'analyse multivariée, comme l'ACP.
# install.packages("FactoMineR")
packages <- c("FactoMineR","ggplot2","ggpubr","cowplot","dplyr","httr", "corrplot", "caret")
for (package in packages) {
if (!requireNamespace(package, quietly = TRUE)) {
install.packages(package)
}
library(package, character.only = TRUE)
}
# # 'plyr' : Manipulation des données et opérations sur des data frames.
# library(plyr)
# # 'corrplot' : Visualisation des corrélations entre variables.
# library(corrplot)
# # 'ggplot2' : Création de graphiques et visualisations de données.
# library(ggplot2)
# # 'gridExtra' : Organisation et mise en page de plusieurs graphiques.
# library(gridExtra)
# # 'ggthemes' : Thèmes et palettes pour ggplot2.
# library(ggthemes)
# # 'caret' : Entraînement et évaluation de modèles de machine learning.
# library(caret)
# # 'party' : Création d'arbres de décision et forêts aléatoires.
# library(party)
# # 'httr' : Interface pour interagir avec les services web via HTTP.
# library(httr)
# # 'cowplot' : Combiner plusieurs graphiques ggplot2 en un seul.
# library(cowplot)
# # 'dplyr' : Manipulation et transformation des données.
# library(dplyr)
# # 'ggpubr' : Graphiques ggplot2 plus présentables.
# library(ggpubr)
# # 'FactoMineR' : Analyse multivariée, comme l'ACP.
# library(FactoMineR)
#
# # 'factoextra' : Visualisation des résultats d'analyse multivariée.
# library(factoextra)
# Apres avoir reduit a 5000 lignes notre dataset, nous celui est sauvegarde sur Google Drive a cette URL
file_url <- "https://drive.google.com/uc?export=download&id=1mgEulx73PFo30imwiCUvLV0fB0DiJc6u"
# Telecharger le dataset depuis Google Drive
GET(file_url, write_disk("Customer-Churn-Records.csv", overwrite = TRUE))
# Chargement du dataset "Customer-Churn-Records.csv" au format CSV dansl'objet data.
data <- read.csv("Customer-Churn-Records.csv")
# Création d'une copie du data frame 'data' dans 'df'.
df <- data
# Affiche les premières lignes du data frame 'df' pour un aperçu rapide.
head(df)
# Affiche la structure du data frame 'df', y compris les types de variables et un résumé des données.
str(df)
colnames(df)  # Affiche les noms des colonnes
#Compter les valeurs manquantes dans chaque colonne
missing_values <- sapply(df, function(x) sum(is.na(x)))
#Créer un dataframe avec les résultats
result <- data.frame(Columns = names(missing_values), Missing_Value_Count = missing_values)
#Afficher le résultat
result
summary(df)
lapply(df, summary)
# Convertit 'Geography' en facteur pour la traiter comme une catégorie.
df$Geography <- as.factor(df$Geography)
# Convertit 'Gender' en facteur pour la traiter comme une catégorie.
df$Gender <- as.factor(df$Gender)
# Transforme 'Tenure' en facteur avec des labels pour chaque niveau.
group_tenure <- function(Tenure)
{
if (Tenure >= 0 & Tenure <= 1){
return('0-1 an')
}else if(Tenure >= 2 & Tenure <= 3){
return('2-3 ans')
}else if (Tenure >= 4 & Tenure <= 5){
return('4-5 ans')
}else if (Tenure > 5 ){
return('> 5 ans')
}
}
df$Tenure <- sapply(df$Tenure,group_tenure)
df$Tenure <- as.factor(df$Tenure)
# Transforme 'HasCrCard' en facteur avec des labels pour chaque niveau.
df$HasCrCard <- factor(df$HasCrCard,
levels = c(0, 1),
labels = c("Pas de carte", "Carte de crédit"))
# Transforme 'IsActiveMember' en facteur avec des labels pour chaque niveau.
df$IsActiveMember <- factor(df$IsActiveMember,
levels = c(0, 1),
labels = c("Non actif", "Actif"))
# Transforme 'Exited' en facteur avec des labels pour chaque niveau.
df$Exited <- factor(df$Exited,
levels = c(0, 1),
labels = c("Resté", "Quitté"))
# Transforme 'Complain' en facteur avec des labels pour chaque niveau.
df$Complain <- factor(df$Complain,
levels = c(0, 1),
labels = c("Pas de plainte", "Plainte"))
# Transforme 'Card.Type' en facteur ordonné avec les labels spécifiés.
df$Card.Type <- factor(df$Card.Type,
levels = c("SILVER", "GOLD", "PLATINUM", "DIAMOND"),
ordered = TRUE)
str(df)
df$RowNumber <- NULL
df$CustomerId <- NULL
df$Surname <- NULL
# Affiche la fréquence des valeurs dans la variable dependante 'Exited' du data frame 'df'.
table(df$Exited)
prop.table(table(df$Exited))
library(ggplot2)
# Crée un graphique en camembert (pie chart) avec ggplot2
ggplot(data = df, aes(x = "", # On met "" pour l'axe x car on veut un seul cercle
y = prop.table(stat(count)), # Les proportions pour l'axe y
fill = Exited,  # Colore les parts du camembert en fonction de 'Exited'
label = scales::percent_format(accuracy=0.01)(prop.table(stat(count))))) +
# Crée des barres pour former le camembert
geom_bar(width = 1, stat = "count") +
# Transformation en camembert
coord_polar(theta = "y") +
# Ajoute les étiquettes sur le camembert
geom_text(stat = 'count',
position = position_stack(vjust = 0.5), # Place les étiquettes au centre des parts
size = 3.5) + # Taille des étiquettes
# Formate l'axe y pour afficher les valeurs en pourcentage
scale_y_continuous(labels = scales::percent_format(accuracy=0.01)) +
# Labels des axes (même s'ils ne sont pas affichés dans un camembert)
labs(x ='', y ="Pourcentage d'Abandon") +
# Titre du graphique
ggtitle('TAUX DE CHUTE') +
# Enlève les lignes et les fonds pour un look plus propre
theme_void()  # Supprime les axes et le fond, ce qui est courant pour les camemberts
str(df)
# Crée un histogramme pour la variable 'CreditScore' avec des barres bleues et des bordures blanches.
s1 <- ggplot(data = df, aes(x=CreditScore)) +
geom_histogram(color="white", fill="blue") +  # Histogramme avec barres bleues et bordures blanches.
theme_bw() +  # Applique un thème avec un arrière-plan blanc.
theme(legend.position = "none")  # Masque la légende du graphique.
# Crée un histogramme pour la variable 'Age' avec des barres violettes et des bordures blanches.
s2 <- ggplot(data = df, aes(x=Age)) +
geom_histogram(color="white", fill="purple") +  # Histogramme avec barres violettes et bordures blanches.
theme_bw() +  # Applique un thème avec un arrière-plan blanc.
theme(legend.position = "none")  # Masque la légende du graphique.
# Crée un histogramme pour la variable 'Balance' avec des barres vertes et des bordures blanches.
s3 <- ggplot(data = df, aes(x=Balance)) +
geom_histogram(color="white", fill="green") +  # Histogramme avec barres vertes et bordures blanches.
theme_bw() +  # Applique un thème avec un arrière-plan blanc.
theme(legend.position = "none",
axis.text.x = element_text(angle = 90, hjust = 1))  # Masque la légende du graphique.
# Crée un histogramme pour la variable 'EstimatedSalary' avec des barres rouges et des bordures blanches.
s4 <- ggplot(data = df, aes(x=EstimatedSalary)) +
geom_histogram(color="white", fill="red") +  # Histogramme avec barres rouges et bordures blanches.
theme_bw() +  # Applique un thème avec un arrière-plan blanc.
theme(legend.position = "none",
axis.text.x = element_text(angle = 90, hjust = 1))  # Masque la légende du graphique.
# Crée un histogramme pour la variable 'Point.Earned' avec des barres rouges et des bordures jaunes.
s5 <- ggplot(data = df, aes(x=Point.Earned)) +
geom_histogram(color="yellow", fill="red") +  # Histogramme avec barres rouges et bordures jaunes.
theme_bw() +  # Applique un thème avec un arrière-plan blanc.
theme(legend.position = "none")  # Masque la légende du graphique.
# Crée un histogramme pour la variable 'NumOfProducts' avec des barres oranges et des bordures vertes.
s6 <- ggplot(data = df, aes(x=NumOfProducts)) +
geom_histogram(color="green", fill="orange") +  # Histogramme avec barres orange et bordures vertes.
theme_bw() +  # Applique un thème avec un arrière-plan blanc.
theme(legend.position = "none")  # Masque la légende du graphique.
# Crée un histogramme pour la variable 'Satisfaction.Score' avec des barres rouges et des bordures jaunes.
s7 <- ggplot(data = df, aes(x=Satisfaction.Score)) +
geom_histogram(color="yellow", fill="red") +  # Histogramme avec barres rouges et bordures jaunes.
theme_bw() +  # Applique un thème avec un arrière-plan blanc.
theme(legend.position = "none")  # Masque la légende du graphique.
# Afficher les graphiques 's1' à 's7' en une seule grille en  leur attribuant automatiquement une lettre
plot_grid(s1, s2, s3,s4, s5,s6, s7,labels = "AUTO")
# Regroupe les données par la variable 'Geography' et calcule le nombre d'occurrences pour chaque groupe.
Geography <- df %>%
group_by(Geography) %>%  # Regroupe les données selon 'Geography'.
summarise(Count = n())  # Calcule le nombre d'occurrences dans chaque groupe et les stocke dans 'Count'.
# Création du diagramme circulaire
p1 <- ggplot(Geography, aes(x = "", y = Count, fill = Geography)) +
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0) +
labs(title = "Répartition par géographie") +
theme_void() +
theme(legend.position = "left") +
geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
position = position_stack(vjust = 0.5), size = 3)
# Regroupe les données par genre et compte les occurrences
Gender <- df %>%
group_by(Gender) %>%
summarise(Count = n())
# Crée le diagramme circulaire
p2 <- ggplot(Gender, aes(x = "", y = Count, fill = Gender)) +
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0) +
labs(title = "Répartition par genre") +
theme_void() +
theme(legend.position = "left") +
geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
position = position_stack(vjust = 0.5), size = 3)
# Regroupement des données par possession de carte de crédit et compte les occurrences
HasCrCard <- df %>%
group_by(HasCrCard) %>%
summarise(Count = n())
# Crée le diagramme circulaire pour la possession de carte de crédit
p3 <- ggplot(HasCrCard, aes(x = "", y = Count, fill = HasCrCard)) +
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0) +
labs(title = "Répartition des clients \n ayant une carte de crédit") +
theme_void() +
theme(legend.position = "left") +
geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
position = position_stack(vjust = 0.5), size = 3)
# Regroupement des données par 'IsActiveMember' et calcul des effectifs
IsActiveMember <- df %>%
group_by(IsActiveMember) %>%
summarise(Count = n())
# Diagramme circulaire pour 'IsActiveMember'
p4 <- ggplot(IsActiveMember, aes(x = "", y = Count, fill = IsActiveMember)) +
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0) +
labs(title = "Répartition des clients actifs") +
theme_void() +
theme(legend.position = "left") +
geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
position = position_stack(vjust = 0.5), size = 3)
# Regroupe les données par la variable 'Tenure' et calcule le nombre d'occurrences pour chaque groupe.
Tenure <- df %>%
group_by(Tenure) %>%  # Regroupe les données selon 'Tenure'.
summarise(Count = n(), .groups = "drop")  # Calcule le nombre d'occurrences dans chaque groupe et les stocke dans 'Count'.
# Crée un graphique à barres pour la variable 'Tenure'.
p5 <- ggbarplot(Tenure,  # Utilise le dataframe 'Tenure' comme source de données.
x = "Tenure",  # Définit 'Tenure' comme variable sur l'axe des x.
y = "Count",  # Définit 'Count' comme variable sur l'axe des y.
fill = "Tenure",  # Remplit les barres avec des couleurs basées sur 'Tenure'.
color = "Tenure",  # Bordure des barres en fonction de 'Tenure'.
palette = c("blue", "purple", "brown2", "red", "cyan1", "green", "yellow", "deeppink1", "forestgreen", "darksalmon", "gold1"),  # Utilise une palette de couleurs personnalisée.
label = TRUE,  # Affiche les étiquettes sur les barres.
lab.size = 2.5,  # Définit la taille des étiquettes.
lab.pos = "out",  # Place les étiquettes à l'extérieur des barres.
lab.col = "black",  # Définit la couleur des étiquettes.
sort.val = "desc",  # Trie les barres par ordre décroissant des valeurs.
sort.by.groups = FALSE) +  # Ne trie pas les barres par groupe.
theme(legend.position = "none",  # Masque la légende du graphique.
axis.text.x = element_text(angle = 90, hjust = 1))  # Fait pivoter les labels de l'axe x à 90 degrés pour éviter le chevauchement.
# Regroupe les données par 'Complain' et calcule les effectifs
Complain <- df %>%
group_by(Complain) %>%
summarise(Count = n())
# Diagramme circulaire pour 'Complain'
p6 <- ggplot(Complain, aes(x = "", y = Count, fill = Complain)) +
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0) +
labs(title = "Répartition des plaintes") +
theme_void() +
theme(legend.position = "left") +
geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
position = position_stack(vjust = 0.5), size = 3)
# Regroupe les données par la variable 'Card.Type' et calcule le nombre d'occurrences pour chaque groupe.
Card.Type <- df %>%
group_by(Card.Type) %>%  # Regroupe les données selon 'Card.Type'.
summarise(Count = n())  # Calcule le nombre d'occurrences dans chaque groupe et les stocke dans 'Count'.
# Crée un graphique à barres pour la variable 'Card.Type'.
p7 <- ggbarplot(Card.Type,  # Utilise le dataframe 'Card.Type' comme source de données.
x = "Card.Type",  # Définit 'Card.Type' comme variable sur l'axe des x.
y = "Count",  # Définit 'Count' comme variable sur l'axe des y.
fill = "Card.Type",  # Remplit les barres avec des couleurs basées sur 'Card.Type'.
color = "Card.Type",  # Bordure des barres en fonction de 'Card.Type'.
palette = "jco",  # Utilise la palette de couleurs "jco".
label = TRUE,  # Affiche les étiquettes sur les barres.
lab.size = 2.5,  # Définit la taille des étiquettes.
lab.pos = "out",  # Place les étiquettes à l'extérieur des barres.
lab.col = "black",  # Définit la couleur des étiquettes.
sort.val = "desc",  # Trie les barres par ordre décroissant des valeurs.
sort.by.groups = FALSE) +  # Ne trie pas les barres par groupe.
theme(legend.position = "none",
axis.text.x = element_text(angle = 90, hjust = 1))  # Masque la légende du graphique.
# Utilise la fonction ggarrange pour organiser plusieurs graphiques en un seul tableau.
ggarrange(p1, p2, p3, p4, p5, p7, p6,  # Liste des graphiques à agencer (p1, p2, p3, p4, p5, p6, p7).
labels = "AUTO",  # Ajoute automatiquement des labels (lettres) pour chaque graphique dans l'agencement.
common.legend = FALSE,  # Ne partage pas de légende commune entre les graphiques.
legend = NULL,  # Exclut toute légende de l'agencement
align = "hv",  # Aligne les graphiques horizontalement et verticalement pour un agencement propre.
ncol = 2)  # Organise les graphiques en 2 colonnes.
# Crée un graphique en boîte pour la variable 'CreditScore' en fonction de 'Exited'.
a1 <- ggplot(df, aes(x = Exited, y = CreditScore, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'CreditScore' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'CreditScore' pour chaque niveau de 'Exited'.
ggtitle("Exited-CREDITSCORE")  # Ajoute un titre au graphique.
# Crée un graphique en boîte pour la variable 'Age' en fonction de 'Exited'.
a2 <- ggplot(df, aes(x = Exited, y = Age, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'Age' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'Age' pour chaque niveau de 'Exited'.
ggtitle("Exited-AGE")  # Ajoute un titre au graphique.
# Crée un graphique en boîte pour la variable 'Balance' en fonction de 'Exited'.
a3 <- ggplot(df, aes(x = Exited, y = Balance, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'Balance' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'Balance' pour chaque niveau de 'Exited'.
ggtitle("Exited-BALANCE")  # Ajoute un titre au graphique.
# Crée un graphique en boîte pour la variable 'EstimatedSalary' en fonction de 'Exited'.
a4 <- ggplot(df, aes(x = Exited, y = EstimatedSalary, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'EstimatedSalary' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'EstimatedSalary' pour chaque niveau de 'Exited'.
ggtitle("Exited-ESTIMATEDSALARY")  # Ajoute un titre au graphique.
# Crée un graphique en boîte pour la variable 'Point.Earned' en fonction de 'Exited'.
a5 <- ggplot(df, aes(x = Exited, y = Point.Earned, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'Point.Earned' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'Point.Earned' pour chaque niveau de 'Exited'.
ggtitle("Exited-Point.Earned")  # Ajoute un titre au graphique.
# Crée un graphique en boîte pour la variable 'NumOfProducts' en fonction de 'Exited'.
a6 <- ggplot(df, aes(x = Exited, y = NumOfProducts, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'NumOfProducts' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'NumOfProducts' pour chaque niveau de 'Exited'.
ggtitle("Exited-NumOfProducts")  # Ajoute un titre au graphique.
# Crée un graphique en boîte pour la variable 'Satisfaction.Score' en fonction de 'Exited'.
a7 <- ggplot(df, aes(x = Exited, y = Satisfaction.Score, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'Satisfaction.Score' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'Satisfaction.Score' pour chaque niveau de 'Exited'.
ggtitle("Exited-Satisfaction.Score")  # Ajoute un titre au graphique.
ggarrange( # Fonction pour arranger plusieurs graphiques en une seule figure.
a1, a2, a3, a4, a5, a6, a7, # Les graphiques que vous souhaitez arranger en une figure (a1 à a7).
labels = "AUTO", # Ajoute des labels automatiques (A, B, C, etc.) à chaque graphique pour les identifier.
common.legend = T, # Utilise une légende commune pour tous les graphiques (au lieu d'avoir une légende séparée pour chaque graphique).
legend = "bottom", # Place la légende commune en bas de la figure.
align = "hv", # Aligne les graphiques à la fois horizontalement ('h') et verticalement ('v').
ncol = 2 # Organise les graphiques en 2 colonnes dans la figure finale.
)
# Calcul des pourcentages pour Geography
Geo <- df %>%
group_by(Geography, Exited) %>%  # Regroupe les données par 'Geography' et 'Exited'
summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Geography' et 'Exited', puis supprime les groupes
group_by(Geography) %>%  # Regroupe de nouveau par 'Geography'
mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Geography'
# Crée un graphique à barres pour les pourcentages par 'Geography'
c1 <- ggbarplot(Geo, x = "Geography", y = "pourcentage",  # Définit 'Geography' comme l'axe des x et 'pourcentage' comme l'axe des y
fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
label = TRUE,  # Affiche les étiquettes sur les barres
lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
lab.size = 2.5,  # Définit la taille des étiquettes
lab.col = "white") +  # Définit la couleur des étiquettes
theme(legend.position = "none")  # Supprime la légende du graphique
# Calcul des pourcentages pour Gender
Gen <- df %>%
group_by(Gender, Exited) %>%  # Regroupe les données par 'Gender' et 'Exited'
summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Gender' et 'Exited', puis supprime les groupes
group_by(Gender) %>%  # Regroupe de nouveau par 'Gender'
mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Gender'
# Crée un graphique à barres pour les pourcentages par 'Gender'
c2 <- ggbarplot(Gen, x = "Gender", y = "pourcentage",  # Définit 'Gender' comme l'axe des x et 'pourcentage' comme l'axe des y
fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
label = TRUE,  # Affiche les étiquettes sur les barres
lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
lab.size = 2.5,  # Définit la taille des étiquettes
lab.col = "white") +  # Définit la couleur des étiquettes
theme(legend.position = "none")  # Supprime la légende du graphique
# Calcul des pourcentages pour HasCrCard
HCrCard <- df %>%
group_by(HasCrCard, Exited) %>%  # Regroupe les données par 'HasCrCard' et 'Exited'
summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'HasCrCard' et 'Exited', puis supprime les groupes
group_by(HasCrCard) %>%  # Regroupe de nouveau par 'HasCrCard'
mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'HasCrCard'
# Crée un graphique à barres pour les pourcentages par 'HasCrCard'
c3 <- ggbarplot(HCrCard, x = "HasCrCard", y = "pourcentage",  # Définit 'HasCrCard' comme l'axe des x et 'pourcentage' comme l'axe des y
fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
label = TRUE,  # Affiche les étiquettes sur les barres
lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
lab.size = 2.5,  # Définit la taille des étiquettes
lab.col = "white") +  # Définit la couleur des étiquettes
theme(legend.position = "none",
axis.text.x = element_text(angle = 90, hjust = 1))  # Supprime la légende du graphique
# Calcul des pourcentages pour IsActiveMember
IsActMember <- df %>%
group_by(IsActiveMember, Exited) %>%  # Regroupe les données par 'IsActiveMember' et 'Exited'
summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'IsActiveMember' et 'Exited', puis supprime les groupes
group_by(IsActiveMember) %>%  # Regroupe de nouveau par 'IsActiveMember'
mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'IsActiveMember'
# Crée un graphique à barres pour les pourcentages par 'IsActiveMember'
c4 <- ggbarplot(IsActMember, x = "IsActiveMember", y = "pourcentage",  # Définit 'IsActiveMember' comme l'axe des x et 'pourcentage' comme l'axe des y
fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
label = TRUE,  # Affiche les étiquettes sur les barres
lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
lab.size = 2.5,  # Définit la taille des étiquettes
lab.col = "white") +  # Définit la couleur des étiquettes
theme(legend.position = "none")  # Supprime la légende du graphique
# Calcul des pourcentages pour Tenure
Ten <- df %>%
group_by(Tenure, Exited) %>%  # Regroupe les données par 'Tenure' et 'Exited'
summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Tenure' et 'Exited', puis supprime les groupes
group_by(Tenure) %>%  # Regroupe de nouveau par 'Tenure'
mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Tenure'
# Crée un graphique à barres pour les pourcentages par 'Tenure'
c5 <- ggbarplot(Ten, x = "Tenure", y = "pourcentage",  # Définit 'Tenure' comme l'axe des x et 'pourcentage' comme l'axe des y
fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
label = TRUE,  # Affiche les étiquettes sur les barres
lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
lab.size = 2.5,  # Définit la taille des étiquettes
lab.col = "white") +  # Définit la couleur des étiquettes
theme(legend.position = "none",
axis.text.x = element_text(angle = 90, hjust = 1))  # Supprime la légende du graphique
# Calcul des pourcentages pour Complain
Complain <- df %>%
group_by(Complain, Exited) %>%  # Regroupe les données par 'Complain' et 'Exited'
summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Complain' et 'Exited', puis supprime les groupes
group_by(Complain) %>%  # Regroupe de nouveau par 'Complain'
mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Complain'
# Crée un graphique à barres pour les pourcentages par 'Complain'
c6 <- ggbarplot(Complain, x = "Complain", y = "pourcentage",  # Définit 'Complain' comme l'axe des x et 'pourcentage' comme l'axe des y
fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
label = TRUE,  # Affiche les étiquettes sur les barres
lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
lab.size = 2.5,  # Définit la taille des étiquettes
lab.col = "white") +  # Définit la couleur des étiquettes
theme(legend.position = "none")  # Supprime la légende du graphique
# Calcul des pourcentages pour Card.Type
Card.Type <- df %>%
group_by(Card.Type, Exited) %>%  # Regroupe les données par 'Card.Type' et 'Exited'
summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Card.Type' et 'Exited', puis supprime les groupes
group_by(Card.Type) %>%  # Regroupe de nouveau par 'Card.Type'
mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Card.Type'
# Crée un graphique à barres pour les pourcentages par 'Card.Type'
c7 <- ggbarplot(Card.Type, x = "Card.Type", y = "pourcentage",  # Définit 'Card.Type' comme l'axe des x et 'pourcentage' comme l'axe des y
fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
label = TRUE,  # Affiche les étiquettes sur les barres
lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
lab.size = 2.5,  # Définit la taille des étiquettes
lab.col = "white") +  # Définit la couleur des étiquettes
theme(legend.position = "none",
axis.text.x = element_text(angle = 90, hjust = 1))  # Supprime la légende du graphique
# Combine les graphiques créés précédemment en une seule image avec plusieurs sous-graphiques
ggarrange(c1, c2, c3, c4, c5, c6, c7,  # Les graphiques à combiner
labels = "AUTO",  # Ajoute automatiquement des labels pour chaque graphique
common.legend = T,  # Affiche une légende commune pour tous les graphiques
legend = "bottom",  # Place la légende en bas de l'image combinée
align = "hv",  # Aligne les graphiques horizontalement et verticalement
ncol = 2)  # Dispose les graphiques en 2 colonnes
str(df)
# Sélectionne uniquement les colonnes numériques du dataframe 'df'
# Utilise la fonction 'select_if' pour filtrer les colonnes en fonction de leur type
data_numeric <- df %>%
select_if(is.numeric)  # 'is.numeric' vérifie si chaque colonne est de type numérique
# Affiche le dataframe contenant uniquement les colonnes numériques
data_numeric
df_scaled <- scale(data_numeric)
# Effectue une analyse en composantes principales (ACP) sur les données normalisées
res.pca = PCA(df_scaled,                # Applique l'ACP sur le dataframe 'df_scaled'
scale.unit=TRUE,          # Normalise les variables pour que chaque variable ait une variance de 1
ncp=5,                   # Extrait les 5 premières composantes principales
graph=T                  # Affiche un graphique des résultats de l'ACP
)
# Fusionner les deux dataframes
data_complete <- cbind(df_scaled, Complain = df$Complain)
# Effectuer l'ACP en incluant Complain comme variable supplémentaire qualitative
res.pca <- PCA(data_complete, scale.unit=TRUE, ncp=5, quali.sup=c(ncol(data_complete)), graph=T)
plot.PCA(res.pca, axes=c(1, 2), choix="ind", habillage=3)
# df$Tenure <- NULL
# Crée une partition aléatoire des données pour l'ensemble d'entraînement et de test
intrain <- createDataPartition(df$Exited,   # Variable pour partitionner les données (ici, 'Exited')
p = 0.7,       # Proportion des données utilisées pour l'entraînement (70%)
list = FALSE)  # Retourne un vecteur des indices, pas une liste
# Définit une graine aléatoire pour assurer la reproductibilité des résultats
set.seed(2024)
# Crée l'ensemble d'entraînement en sélectionnant les lignes correspondant aux indices de 'intrain'
training <- df[intrain,]
# Crée l'ensemble de test en sélectionnant les lignes qui ne sont pas dans 'intrain'
testing <- df[-intrain,]
# Affiche les dimensions de l'ensemble d'entraînement et de l'ensemble de test
dim(training)   # Affiche le nombre de lignes et de colonnes de l'ensemble d'entraînement
dim(testing)    # Affiche le nombre de lignes et de colonnes de l'ensemble de test
# pour les donnees d'entrainnement
prop.table(table(training$Exited))
# pour les donnees de test
prop.table(table(testing$Exited))
LogModel <- glm(Exited ~ .,                # Formule du modèle : 'Exited' est la variable cible, '.' signifie toutes les autres variables comme prédicteurs
family = binomial(link = "logit"),  # Spécifie que le modèle est une régression logistique avec la fonction de lien 'logit'
data = training)        # Utilise l'ensemble de données d'entraînement pour ajuster le modèle
# Affiche le résumé du modèle pour voir les coefficients, les statistiques de significativité, etc.
print(summary(LogModel))    # Résumé du modèle affichant les détails sur les variables, les coefficients, les p-values, etc.
# Convertit la variable 'Exited' dans l'ensemble de données de test en type caractère
testing$Exited <- as.character(testing$Exited)   # Transforme 'Exited' en chaîne de caractères pour pouvoir modifier les valeurs
# Remplace les valeurs "Resté" par "0" dans la variable 'Exited'
testing$Exited[testing$Exited == "Resté"] <- "0"   # Remplace toutes les occurrences de "Resté" par "0"
# Remplace les valeurs "Quitté" par "1" dans la variable 'Exited'
testing$Exited[testing$Exited == "Quitté"] <- "1"   # Remplace toutes les occurrences de "Quitté" par "1"
# Prédit les probabilités de sortie à l'aide du modèle logistique
fitted.results <- predict(LogModel,                   # Utilise le modèle LogModel pour faire des prédictions
newdata = testing,          # Prédictions sur les données de test
type = 'response')         # Type de prédiction : 'response' donne des probabilités
# Sélectionne aléatoirement 6 observations pour vérifier leurs probabilités prédites
set.seed(2024)  # Assure la reproductibilité de l'échantillonnage aléatoire
random_indices <- sample(1:nrow(testing), 6)  # Sélectionne 6 indices aléatoires
selected_results <- fitted.results[random_indices]  # Récupère les probabilités pour ces indices
selected_results  # Affiche les probabilités des 6 observations sélectionnées
# Optionnel : Affiche également les valeurs réelles correspondantes pour comparaison
selected_actual <- testing$Exited[random_indices]
data.frame(Probabilities = selected_results, Actual = selected_actual)
# Convertit les probabilités en classes binaires en utilisant un seuil de 0.5
fitted.results <- ifelse(fitted.results > 0.5, 1, 0)  # Si la probabilité est > 0.5, prédiction = 1 (Quitté), sinon 0 (Resté)
# Calcule l'erreur de classification en comparant les prédictions avec les valeurs réelles
misClasificError <- mean(fitted.results != testing$Exited)  # Moyenne des erreurs de classification
# Affiche l'exactitude du modèle de régression logistique
print(paste('Logistic Regression Accuracy', 1 - misClasificError))   # Affiche l'exactitude du modèle (1 - erreur de classification)
# Affiche la matrice de confusion pour évaluer les performances du modèle
print("Confusion Matrix for Logistic Regression")   # Affiche un message pour indiquer que la matrice de confusion sera affichée
table(testing$Exited, fitted.results > 0.5)    # Crée une table croisée pour montrer les résultats réels vs prédits
