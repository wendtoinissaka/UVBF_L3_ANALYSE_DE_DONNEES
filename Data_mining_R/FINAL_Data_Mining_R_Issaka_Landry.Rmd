---
title: "Data_Mining_R_Issaka_Landry"
author: "OUEDRAOGO WENDTOIN ISSAKA et  SOME FIARMA LANDRY"
date: "`r Sys.Date()`"
output: html_notebook
---


# **PREDIRE LE DESABONNEMENT DES CLIENTS BANCAIRES**
![](img/Churn-Prediction-scaled.jpg)

# -----------------------------------------------------------------------------------------
## **INTRDOCUTION**
# -----------------------------------------------------------------------------------------

  *La perte de clients est devenue un enjeu majeur pour le secteur bancaire, impactant directement la rentabilité des institutions financières. Conserver un client coûte en moyenne cinq fois moins cher que d'en acquérir un nouveau (Khan et al., 2010), soulignant l'importance de la fidélisation. En réponse, les banques doivent développer des stratégies efficaces pour prédire les comportements de désabonnement afin de réduire les pertes et améliorer la rétention.*
  
  *L’objectif de ce projet est de mettre en œuvre des modèles d’apprentissage automatique pour prédire les clients les plus susceptibles de se désabonner. Ce processus implique l'utilisation de techniques de classification sur des données historiques pour identifier les signaux précurseurs de désabonnement, permettant ainsi aux banques de mettre en place des mesures préventives adaptées.*




# -----------------------------------------------------------------------------------------
## Partie I : **Présentation de la Problématique**
# -----------------------------------------------------------------------------------------

 La perte de clients est un enjeu crucial pour les banques. Garder un client coûte beaucoup moins cher que d'en attirer un nouveau. Pour y remédier, les banques doivent prédire quels clients risquent de partir afin de mettre en place des actions préventives efficaces.

Objectifs du projet :

    Identifier les facteurs clés : Quels aspects du profil des clients sont liés au désabonnement ?
    Développer un modèle prédictif : Créer un modèle pour estimer la probabilité qu'un client se désabonne.
    Évaluer le modèle : Mesurer la précision du modèle pour garantir son efficacité.

Pourquoi c'est important :

    Réduction des coûts : Prévenir le désabonnement aide à éviter les coûts élevés liés à l'acquisition de nouveaux clients.
    Amélioration du service : En comprenant les raisons du désabonnement, les banques peuvent améliorer leur offre et fidéliser leurs clients.
    Avantage concurrentiel : Une meilleure rétention des clients peut offrir un avantage compétitif significatif.

Ce projet vise à utiliser des techniques de classification pour prédire le désabonnement des clients, afin d'aider les banques à mieux gérer leur relation client et à optimiser leur stratégie de fidélisation.



  




# -----------------------------------------------------------------------------------------
## Partie II : **Présentation de la Base de Données, de sa Structure et de ses Variables**
# -----------------------------------------------------------------------------------------
**Vue d'ensemble du jeu de données**
*Pour la réalisation de notre travail, nous allons utiliser un jeu de données obtenu depuis ([Kaggle](https://www.kaggle.com/datasets/radheshyamkollipara/bank-customer-churn)), une plateforme renommée pour les passionnés et les praticiens de la science des données. Le jeu de données contient des informations précieuses sur les clients de la banque et divers attributs pouvant influencer leur décision de quitter la banque.*


####    Installation des differentes bibliothèques à utilisers
*Decommenter les lignes des bibliothèques non installées pour les installées*
```{r}
# # 'httr' : Pour faire des requêtes HTTP et interagir avec des API.
# install.packages("httr")
# 
# # 'cowplot' : Pour combiner plusieurs graphiques ggplot2 en un seul.
# install.packages("cowplot")
# 
# # 'dplyr' : Pour manipuler et transformer des données facilement.
# install.packages("dplyr")
# 
# # 'ggpubr' : Pour rendre les graphiques ggplot2 plus présentables.
# install.packages("ggpubr")
# 
# # 'ggplot2' : Pour créer des graphiques de qualité en R.
# install.packages("ggplot2")
# 
# # 'FactoMineR' : Pour l'analyse multivariée, comme l'ACP.
# install.packages("FactoMineR")

packages <- c("FactoMineR","ggplot2","ggpubr","cowplot","dplyr","httr", "corrplot", "caret")

for (package in packages) {
  if (!requireNamespace(package, quietly = TRUE)) {
    install.packages(package)
  }
  library(package, character.only = TRUE)
}

```





###   Chargement des packages necessaires
```{r}
# # 'plyr' : Manipulation des données et opérations sur des data frames.
# library(plyr)
# # 'corrplot' : Visualisation des corrélations entre variables.
# library(corrplot)
# # 'ggplot2' : Création de graphiques et visualisations de données.
# library(ggplot2)
# # 'gridExtra' : Organisation et mise en page de plusieurs graphiques.
# library(gridExtra)
# # 'ggthemes' : Thèmes et palettes pour ggplot2.
# library(ggthemes)
# # 'caret' : Entraînement et évaluation de modèles de machine learning.
# library(caret)
# # 'party' : Création d'arbres de décision et forêts aléatoires.
# library(party)
# # 'httr' : Interface pour interagir avec les services web via HTTP.
# library(httr)
# # 'cowplot' : Combiner plusieurs graphiques ggplot2 en un seul.
# library(cowplot)
# # 'dplyr' : Manipulation et transformation des données.
# library(dplyr)
# # 'ggpubr' : Graphiques ggplot2 plus présentables.
# library(ggpubr)
# # 'FactoMineR' : Analyse multivariée, comme l'ACP.
# library(FactoMineR)
# 
# # 'factoextra' : Visualisation des résultats d'analyse multivariée.
# library(factoextra)

```

###   chargement du  dataset
```{r }
# Apres avoir reduit a 5000 lignes notre dataset, nous celui est sauvegarde sur Google Drive a cette URL
file_url <- "https://drive.google.com/uc?export=download&id=1mgEulx73PFo30imwiCUvLV0fB0DiJc6u"

# Telecharger le dataset depuis Google Drive
GET(file_url, write_disk("Customer-Churn-Records.csv", overwrite = TRUE))

# Chargement du dataset "Customer-Churn-Records.csv" au format CSV dansl'objet data.
data <- read.csv("Customer-Churn-Records.csv")

# Création d'une copie du data frame 'data' dans 'df'.
df <- data

```

```{r}
# Affiche les premières lignes du data frame 'df' pour un aperçu rapide.
head(df)

# Affiche la structure du data frame 'df', y compris les types de variables et un résumé des données.
str(df)
```


Extraction des donnnees et nettoyage
```{r}
 
  colnames(df)  # Affiche les noms des colonnes

```

Voir les valeurs manquantes
```{r}
#Compter les valeurs manquantes dans chaque colonne
missing_values <- sapply(df, function(x) sum(is.na(x)))

#Créer un dataframe avec les résultats 
result <- data.frame(Columns = names(missing_values), Missing_Value_Count = missing_values)

#Afficher le résultat 
result
```


Affiche un résumé statistique des colonnes du data frame 'df'
```{r}

summary(df)

```

Afficher un résumé statistique détaillé de chaque variable du data frame.
```{r}

lapply(df, summary)

```



Transformer ces variables en facteurs
```{r}
# Convertit 'Geography' en facteur pour la traiter comme une catégorie.
df$Geography <- as.factor(df$Geography)

# Convertit 'Gender' en facteur pour la traiter comme une catégorie.
df$Gender <- as.factor(df$Gender)

# Transforme 'Tenure' en facteur avec des labels pour chaque niveau.
group_tenure <- function(Tenure)
{
    if (Tenure >= 0 & Tenure <= 1){
        return('0-1 an')
    }else if(Tenure >= 2 & Tenure <= 3){
        return('2-3 ans')
    }else if (Tenure >= 4 & Tenure <= 5){
        return('4-5 ans')
    }else if (Tenure > 5 ){
        return('> 5 ans')
 }
}

df$Tenure <- sapply(df$Tenure,group_tenure)
df$Tenure <- as.factor(df$Tenure)


# Transforme 'HasCrCard' en facteur avec des labels pour chaque niveau.
df$HasCrCard <- factor(df$HasCrCard, 
                       levels = c(0, 1), 
                       labels = c("Pas de carte", "Carte de crédit"))

# Transforme 'IsActiveMember' en facteur avec des labels pour chaque niveau.
df$IsActiveMember <- factor(df$IsActiveMember, 
                            levels = c(0, 1), 
                            labels = c("Non actif", "Actif"))

# Transforme 'Exited' en facteur avec des labels pour chaque niveau.
df$Exited <- factor(df$Exited, 
                    levels = c(0, 1), 
                    labels = c("Resté", "Quitté"))

# Transforme 'Complain' en facteur avec des labels pour chaque niveau.
df$Complain <- factor(df$Complain, 
                      levels = c(0, 1), 
                      labels = c("Pas de plainte", "Plainte"))

# Transforme 'Card.Type' en facteur ordonné avec les labels spécifiés.
df$Card.Type <- factor(df$Card.Type, 
                       levels = c("SILVER", "GOLD", "PLATINUM", "DIAMOND"),
                       ordered = TRUE)





```

 Affiche la structure du data frame 'df', montrant les types de variables et un aperçu des données après la transformation en facteurs.
```{r}

str(df)

```
Supprimer les colonnes non necessaires
```{r}

  df$RowNumber <- NULL
  df$CustomerId <- NULL
  df$Surname <- NULL
```



**Conclusion**

  Nous pouvons voir que nous avons des variables catégorielles et continues, et nous constatons également qu'il n'y a pas de valeurs nulles.

### Variables et leur Impact

- **RowNumber** : correspond au numéro de l'enregistrement (ligne) et n'a aucun effet sur le résultat.

- **CustomerId** : contient des valeurs aléatoires et n'a pas d'effet sur le départ du client de la banque.

- **Surname** : le nom de famille d'un client n'a pas d'impact sur sa décision de quitter la banque.

- **CreditScore** : peut avoir un effet sur l'attrition des clients, puisque les clients ayant un score de crédit plus élevé sont moins susceptibles de quitter la banque.

- **Geography** : la localisation d'un client peut influencer sa décision de quitter la banque.

- **Gender** : il est intéressant d'explorer si le genre joue un rôle dans la décision d'un client de quitter la banque.

- **Age** : c'est certainement pertinent, car les clients plus âgés sont moins susceptibles de quitter leur banque que les plus jeunes.

- **Tenure** : fait référence au nombre d'années durant lesquelles le client a été client de la banque. En général, les clients plus anciens sont plus loyaux et moins susceptibles de quitter la banque.

- **Balance** : également un très bon indicateur de l'attrition des clients, car les personnes ayant un solde plus élevé sur leurs comptes sont moins susceptibles de quitter la banque par rapport à celles ayant des soldes plus faibles.

- **NumOfProducts** : fait référence au nombre de produits que le client a achetés auprès de la banque.

- **HasCrCard** : indique si le client possède ou non une carte de crédit. Cette colonne est également pertinente, car les personnes ayant une carte de crédit sont moins susceptibles de quitter la banque.

- **IsActiveMember** : les clients actifs sont moins susceptibles de quitter la banque.

- **EstimatedSalary** : comme pour le solde, les personnes ayant des salaires plus bas sont plus susceptibles de quitter la banque par rapport à celles ayant des salaires plus élevés.

- **Exited** : indique si le client a quitté la banque ou non.

- **Complain** : indique si le client a déposé une plainte ou non.

- **Satisfaction.Score** : score fourni par le client pour la résolution de sa plainte.

- **Card.Type** : type de carte détenue par le client.

- **Points.Earned** : les points gagnés par le client pour l'utilisation de la carte de crédit.



# -----------------------------------------------------------------------------------------
## Partie III : **Analyse Descriptive**
# -----------------------------------------------------------------------------------------


###  Analyse univarisee

*Analyse de la variable objective*
```{r}

# Affiche la fréquence des valeurs dans la variable dependante 'Exited' du data frame 'df'.
table(df$Exited)
```


Mettre en pourcentage la variable cible
```{r}
  prop.table(table(df$Exited))
```

Representation graphique
```{r}
library(ggplot2)

# Crée un graphique en camembert (pie chart) avec ggplot2
ggplot(data = df, aes(x = "", # On met "" pour l'axe x car on veut un seul cercle
                      y = prop.table(stat(count)), # Les proportions pour l'axe y
                      fill = Exited,  # Colore les parts du camembert en fonction de 'Exited'
                      label = scales::percent_format(accuracy=0.01)(prop.table(stat(count))))) + 
  
  # Crée des barres pour former le camembert
  geom_bar(width = 1, stat = "count") + 
  
  # Transformation en camembert
  coord_polar(theta = "y") +
  
  # Ajoute les étiquettes sur le camembert
  geom_text(stat = 'count', 
            position = position_stack(vjust = 0.5), # Place les étiquettes au centre des parts
            size = 3.5) + # Taille des étiquettes
  
  # Formate l'axe y pour afficher les valeurs en pourcentage
  scale_y_continuous(labels = scales::percent_format(accuracy=0.01)) +

  # Labels des axes (même s'ils ne sont pas affichés dans un camembert)
  labs(x ='', y ="Pourcentage d'Abandon") +    
  
  # Titre du graphique
  ggtitle('TAUX DE CHUTE') + 
  
  # Enlève les lignes et les fonds pour un look plus propre
  theme_void()  # Supprime les axes et le fond, ce qui est courant pour les camemberts


```
  *Le nombre de clients qui restent dans la banque est nettement plus élevé que ceux qui la quittent.*


```{r}



```

```{r}
str(df)
```


*Analyse des variables continues*
```{r}

# Crée un histogramme pour la variable 'CreditScore' avec des barres bleues et des bordures blanches.
s1 <- ggplot(data = df, aes(x=CreditScore)) +
    geom_histogram(color="white", fill="blue") +  # Histogramme avec barres bleues et bordures blanches.
    theme_bw() +  # Applique un thème avec un arrière-plan blanc.
    theme(legend.position = "none")  # Masque la légende du graphique.

# Crée un histogramme pour la variable 'Age' avec des barres violettes et des bordures blanches.
s2 <- ggplot(data = df, aes(x=Age)) +
    geom_histogram(color="white", fill="purple") +  # Histogramme avec barres violettes et bordures blanches.
    theme_bw() +  # Applique un thème avec un arrière-plan blanc.
    theme(legend.position = "none")  # Masque la légende du graphique.

# Crée un histogramme pour la variable 'Balance' avec des barres vertes et des bordures blanches.
s3 <- ggplot(data = df, aes(x=Balance)) +
    geom_histogram(color="white", fill="green") +  # Histogramme avec barres vertes et bordures blanches.
    theme_bw() +  # Applique un thème avec un arrière-plan blanc.
    theme(legend.position = "none", 
          axis.text.x = element_text(angle = 90, hjust = 1))  # Masque la légende du graphique.

# Crée un histogramme pour la variable 'EstimatedSalary' avec des barres rouges et des bordures blanches.
s4 <- ggplot(data = df, aes(x=EstimatedSalary)) +
    geom_histogram(color="white", fill="red") +  # Histogramme avec barres rouges et bordures blanches.
    theme_bw() +  # Applique un thème avec un arrière-plan blanc.
    theme(legend.position = "none",
          axis.text.x = element_text(angle = 90, hjust = 1))  # Masque la légende du graphique.

# Crée un histogramme pour la variable 'Point.Earned' avec des barres rouges et des bordures jaunes.
s5 <- ggplot(data = df, aes(x=Point.Earned)) +
    geom_histogram(color="yellow", fill="red") +  # Histogramme avec barres rouges et bordures jaunes.
    theme_bw() +  # Applique un thème avec un arrière-plan blanc.
    theme(legend.position = "none")  # Masque la légende du graphique.

# Crée un histogramme pour la variable 'NumOfProducts' avec des barres oranges et des bordures vertes.
s6 <- ggplot(data = df, aes(x=NumOfProducts)) +
    geom_histogram(color="green", fill="orange") +  # Histogramme avec barres orange et bordures vertes.
    theme_bw() +  # Applique un thème avec un arrière-plan blanc.
    theme(legend.position = "none")  # Masque la légende du graphique.

# Crée un histogramme pour la variable 'Satisfaction.Score' avec des barres rouges et des bordures jaunes.
s7 <- ggplot(data = df, aes(x=Satisfaction.Score)) +
    geom_histogram(color="yellow", fill="red") +  # Histogramme avec barres rouges et bordures jaunes.
    theme_bw() +  # Applique un thème avec un arrière-plan blanc.
    theme(legend.position = "none")  # Masque la légende du graphique.

```


```{r}
# Afficher les graphiques 's1' à 's7' en une seule grille en  leur attribuant automatiquement une lettre

  plot_grid(s1, s2, s3,s4, s5,s6, s7,labels = "AUTO")
```
    
  *La plage de cote de crédit (CreditScore) est distribuée normalement, la cote de crédit la plus élevée étant établie entre 600 et 700.*
  
  *Par âge, on constate que le nombre de clients des banques est nettement plus élevé entre 25 et 50 ans (et dans cet intervalle entre 30 et 40 ans environ), le nombre de clients étant beaucoup plus faible dans les autres tranches d’âge. clients et à partir de 50 ans, ils sont considérablement réduits. (courbe avec une plus grande asymétrie vers la droite).*
  *Il existe un grand nombre de clients avec un Solde de 0, important au-delà de 3500 clients, le reste des clients a un Solde selon une distribution normale.*
  
  *Pour le salaire estimé, il est assez égal dans tous les niveaux de salaire des clients, à l'exception de ceux de 0 et 200 000, qui sont les 2 groupes de clients qui se situent à des niveaux différents en général en termes de nombre de clients dans cette relation.*
  
  *Quant aux points gagnés par le client pour l'utilisation d'une carte de crédit, il est quasiment egal pour tous les niveaux a l'exception de ceux  de 220 et 1000 ,qui sont les 2 groupes de clients qui se situent à des niveaux différents en général en termes de nombre de clients dans cette relation.*
  
  *La majorité des clients sont détenteurs d'un ou deux produits financiers de la banque, très nettement au-dessus de ceux qui en possèdent 3 ou 4 comme groupes minoritaires.*
  
  *Nous avons quasiment le meme nombre de clients pour les differents scores de satisfaction*

 






####   Analyse des variables categorielles
```{r}


# Regroupe les données par la variable 'Geography' et calcule le nombre d'occurrences pour chaque groupe.
Geography <- df %>%
  group_by(Geography) %>%  # Regroupe les données selon 'Geography'.
  summarise(Count = n())  # Calcule le nombre d'occurrences dans chaque groupe et les stocke dans 'Count'.

# Création du diagramme circulaire
p1 <- ggplot(Geography, aes(x = "", y = Count, fill = Geography)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  labs(title = "Répartition par géographie") +
  theme_void() +
  theme(legend.position = "left") +
  geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
            position = position_stack(vjust = 0.5), size = 3)




# Regroupe les données par genre et compte les occurrences
Gender <- df %>%
  group_by(Gender) %>%
  summarise(Count = n())

# Crée le diagramme circulaire
p2 <- ggplot(Gender, aes(x = "", y = Count, fill = Gender)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  labs(title = "Répartition par genre") +
  theme_void() +
  theme(legend.position = "left") +
  geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
            position = position_stack(vjust = 0.5), size = 3)



# Regroupement des données par possession de carte de crédit et compte les occurrences
HasCrCard <- df %>%
  group_by(HasCrCard) %>%
  summarise(Count = n())

# Crée le diagramme circulaire pour la possession de carte de crédit
p3 <- ggplot(HasCrCard, aes(x = "", y = Count, fill = HasCrCard)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  labs(title = "Répartition des clients \n ayant une carte de crédit") +
  theme_void() +
  theme(legend.position = "left") +
  geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
            position = position_stack(vjust = 0.5), size = 3)


# Regroupement des données par 'IsActiveMember' et calcul des effectifs
IsActiveMember <- df %>%
  group_by(IsActiveMember) %>%
  summarise(Count = n())

# Diagramme circulaire pour 'IsActiveMember'
p4 <- ggplot(IsActiveMember, aes(x = "", y = Count, fill = IsActiveMember)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  labs(title = "Répartition des clients actifs") +
  theme_void() +
  theme(legend.position = "left") +
  geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
            position = position_stack(vjust = 0.5), size = 3)

# Regroupe les données par la variable 'Tenure' et calcule le nombre d'occurrences pour chaque groupe.
Tenure <- df %>%
  group_by(Tenure) %>%  # Regroupe les données selon 'Tenure'.
  summarise(Count = n(), .groups = "drop")  # Calcule le nombre d'occurrences dans chaque groupe et les stocke dans 'Count'.

# Crée un graphique à barres pour la variable 'Tenure'.
p5 <- ggbarplot(Tenure,  # Utilise le dataframe 'Tenure' comme source de données.
                x = "Tenure",  # Définit 'Tenure' comme variable sur l'axe des x.
                y = "Count",  # Définit 'Count' comme variable sur l'axe des y.
                fill = "Tenure",  # Remplit les barres avec des couleurs basées sur 'Tenure'.
                color = "Tenure",  # Bordure des barres en fonction de 'Tenure'.
                palette = c("blue", "purple", "brown2", "red", "cyan1", "green", "yellow", "deeppink1", "forestgreen", "darksalmon", "gold1"),  # Utilise une palette de couleurs personnalisée.
                label = TRUE,  # Affiche les étiquettes sur les barres.
                lab.size = 2.5,  # Définit la taille des étiquettes.
                lab.pos = "out",  # Place les étiquettes à l'extérieur des barres.
                lab.col = "black",  # Définit la couleur des étiquettes.
                sort.val = "desc",  # Trie les barres par ordre décroissant des valeurs.
                sort.by.groups = FALSE) +  # Ne trie pas les barres par groupe.
      theme(legend.position = "none",  # Masque la légende du graphique.
            axis.text.x = element_text(angle = 90, hjust = 1))  # Fait pivoter les labels de l'axe x à 90 degrés pour éviter le chevauchement.


# Regroupe les données par 'Complain' et calcule les effectifs
Complain <- df %>%
  group_by(Complain) %>%
  summarise(Count = n())

# Diagramme circulaire pour 'Complain'
p6 <- ggplot(Complain, aes(x = "", y = Count, fill = Complain)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  labs(title = "Répartition des plaintes") +
  theme_void() +
  theme(legend.position = "left") +
  geom_text(aes(label = paste0(round(Count/sum(Count)*100), "%")),
            position = position_stack(vjust = 0.5), size = 3)

# Regroupe les données par la variable 'Card.Type' et calcule le nombre d'occurrences pour chaque groupe.
Card.Type <- df %>%
  group_by(Card.Type) %>%  # Regroupe les données selon 'Card.Type'.
  summarise(Count = n())  # Calcule le nombre d'occurrences dans chaque groupe et les stocke dans 'Count'.

# Crée un graphique à barres pour la variable 'Card.Type'.
p7 <- ggbarplot(Card.Type,  # Utilise le dataframe 'Card.Type' comme source de données.
                x = "Card.Type",  # Définit 'Card.Type' comme variable sur l'axe des x.
                y = "Count",  # Définit 'Count' comme variable sur l'axe des y.
                fill = "Card.Type",  # Remplit les barres avec des couleurs basées sur 'Card.Type'.
                color = "Card.Type",  # Bordure des barres en fonction de 'Card.Type'.
                palette = "jco",  # Utilise la palette de couleurs "jco".
                label = TRUE,  # Affiche les étiquettes sur les barres.
                lab.size = 2.5,  # Définit la taille des étiquettes.
                lab.pos = "out",  # Place les étiquettes à l'extérieur des barres.
                lab.col = "black",  # Définit la couleur des étiquettes.
                sort.val = "desc",  # Trie les barres par ordre décroissant des valeurs.
                sort.by.groups = FALSE) +  # Ne trie pas les barres par groupe.
      theme(legend.position = "none",
            axis.text.x = element_text(angle = 90, hjust = 1))  # Masque la légende du graphique.



```

```{r}

```

```{r}
# Utilise la fonction ggarrange pour organiser plusieurs graphiques en un seul tableau.
ggarrange(p1, p2, p3, p4, p5, p7, p6,  # Liste des graphiques à agencer (p1, p2, p3, p4, p5, p6, p7).
          labels = "AUTO",  # Ajoute automatiquement des labels (lettres) pour chaque graphique dans l'agencement.
          common.legend = FALSE,  # Ne partage pas de légende commune entre les graphiques.
          legend = NULL,  # Exclut toute légende de l'agencement 
          align = "hv",  # Aligne les graphiques horizontalement et verticalement pour un agencement propre.
          ncol = 2)  # Organise les graphiques en 2 colonnes.


```
  *Les clients sont essentiellement originaires de 3 pays, la France, l'Allemagne et l'Espagne dont 51% de Francais, 25% d'Allemands et 24% d'Espanols.*
  
  *Les clients de cette banques sont composes de 55% d'hommes et 45% de femmes.*
  
  *70% des clients possedent une carte de credit contre 30% qui n'en possedent pas.*
  
  *52% des clients sont des clients actifs de la banque par rapport a 48% non actifs.*
  
  *Les clients ayant une anciennete de plus de 5ans sont les plus majoritairs(2247) suivis de ceux ayant 2 ou 3 ans d'ancienntes(1040) puis ceux ayant 4 ou 5ans d'anciennete(989). Peu de clients ont une anciennete de moins d'un an*
  
  *Pour chaque type de carte, presqu'un quart des clients en possede. Comme illustre le graphique, 1256 clients sont detenteurs d'une carte en Or, 1254 possedent la carte en Argent, 1251 ont une carte en Platine et 1239 clients sont proprietaires d'une carte en Diamant*
  
  *seulement 20% des clients portent une plainte contre la banque par rapport a 80% d'entre eux ne se plaignent pas*
  
  
 




###  Analyse bivariée


*Comparons nos variables continues avec la variable cible spécifiée.*
```{r}
# Crée un graphique en boîte pour la variable 'CreditScore' en fonction de 'Exited'.
a1 <- ggplot(df, aes(x = Exited, y = CreditScore, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'CreditScore' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
  geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'CreditScore' pour chaque niveau de 'Exited'.
  ggtitle("Exited-CREDITSCORE")  # Ajoute un titre au graphique.

# Crée un graphique en boîte pour la variable 'Age' en fonction de 'Exited'.
a2 <- ggplot(df, aes(x = Exited, y = Age, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'Age' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
  geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'Age' pour chaque niveau de 'Exited'.
  ggtitle("Exited-AGE")  # Ajoute un titre au graphique.

# Crée un graphique en boîte pour la variable 'Balance' en fonction de 'Exited'.
a3 <- ggplot(df, aes(x = Exited, y = Balance, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'Balance' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
  geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'Balance' pour chaque niveau de 'Exited'.
  ggtitle("Exited-BALANCE")  # Ajoute un titre au graphique.

# Crée un graphique en boîte pour la variable 'EstimatedSalary' en fonction de 'Exited'.
a4 <- ggplot(df, aes(x = Exited, y = EstimatedSalary, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'EstimatedSalary' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
  geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'EstimatedSalary' pour chaque niveau de 'Exited'.
  ggtitle("Exited-ESTIMATEDSALARY")  # Ajoute un titre au graphique.

# Crée un graphique en boîte pour la variable 'Point.Earned' en fonction de 'Exited'.
a5 <- ggplot(df, aes(x = Exited, y = Point.Earned, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'Point.Earned' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
  geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'Point.Earned' pour chaque niveau de 'Exited'.
  ggtitle("Exited-Point.Earned")  # Ajoute un titre au graphique.

# Crée un graphique en boîte pour la variable 'NumOfProducts' en fonction de 'Exited'.
a6 <- ggplot(df, aes(x = Exited, y = NumOfProducts, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'NumOfProducts' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
  geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'NumOfProducts' pour chaque niveau de 'Exited'.
  ggtitle("Exited-NumOfProducts")  # Ajoute un titre au graphique.

# Crée un graphique en boîte pour la variable 'Satisfaction.Score' en fonction de 'Exited'.
a7 <- ggplot(df, aes(x = Exited, y = Satisfaction.Score, fill = Exited)) +  # Définit 'Exited' pour l'axe x et 'Satisfaction.Score' pour l'axe y. Les barres sont remplies en fonction de 'Exited'.
  geom_boxplot() +  # Crée un graphique en boîte pour visualiser la distribution de 'Satisfaction.Score' pour chaque niveau de 'Exited'.
  ggtitle("Exited-Satisfaction.Score")  # Ajoute un titre au graphique.

```

```{r}
ggarrange( # Fonction pour arranger plusieurs graphiques en une seule figure.
  a1, a2, a3, a4, a5, a6, a7, # Les graphiques que vous souhaitez arranger en une figure (a1 à a7).
  labels = "AUTO", # Ajoute des labels automatiques (A, B, C, etc.) à chaque graphique pour les identifier.
  common.legend = T, # Utilise une légende commune pour tous les graphiques (au lieu d'avoir une légende séparée pour chaque graphique).
  legend = "bottom", # Place la légende commune en bas de la figure.
  align = "hv", # Aligne les graphiques à la fois horizontalement ('h') et verticalement ('v').
  ncol = 2 # Organise les graphiques en 2 colonnes dans la figure finale.
)

```
  *On peut dire en ce qui concerne la fourchette de score de crédit (CreditScore) qu'en termes d'abandon, elle est très similaire à celle des clients qui ne l'abandonnent pas, même dans une fourchette de valeurs équivalentes comprises entre env. 600-700 crédits, sa variance étant pratiquement très similaire autour de la moyenne.*
  
  *Dans la plupart des cas, les clients entre 30 et 40 ans ne quittent pas la banque, de 40 à 50 ans il y a le taux d'abandon le plus élevé, la variance de ceux qui ne partent pas est un peu inférieure à celle des clients qu'ils abandonnent en cet égard.*
  
  *Concernant le solde, le taux d'abandon et de non-abandon s'équilibre entre clients entre env. 40 000 et un peu supérieur à 110 000, leurs moyennes respectives étant comprises entre environ 90 000 (Resté) et 110 000 (Abandoné). La variance de ceux qui n'abandonnent pas est plus grande que celle de ceux qui abandonnent, ceux qui abandonnent le font sur la base d'un solde d'env. de 40 000 dans une fourchette comprise entre 40 000 et 130 000 environ.*
  
  *Le salaire estimé (estimatedsalary) est pratiquement le même en proportion entre ceux qui partent et ceux qui ne partent pas (à peu près le même écart) et sa moyenne pour chacun d'eux est supérieure à 100 000 du salaire estimé.*
  
  *Le nombre de points accumules lors de l'utilisation des cartes est pratiquement le même en proportion entre ceux qui partent et ceux qui ne partent pas .*
  
  *Le taux d'abandon des clients qui ont entre 3 et 4 comme nombre de produits en banque est très nettement supérieur à ceux qui en ont 1 ou 2 (le taux d'abandon de ceux qui en ont 4 est de 100%).*
  
  *Le taux d’abandon des clients, compte tenu du score de satisfaction , est similaire dans tous les cas quel que soit le score de satisfaction .*





**Nous comparons maintenant chaque variable catégorielle par rapport à notre variable cible pour tirer des conclusions **
```{r}

# Calcul des pourcentages pour Geography
Geo <- df %>%
  group_by(Geography, Exited) %>%  # Regroupe les données par 'Geography' et 'Exited'
  summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Geography' et 'Exited', puis supprime les groupes
  group_by(Geography) %>%  # Regroupe de nouveau par 'Geography'
  mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Geography'

# Crée un graphique à barres pour les pourcentages par 'Geography'
c1 <- ggbarplot(Geo, x = "Geography", y = "pourcentage",  # Définit 'Geography' comme l'axe des x et 'pourcentage' comme l'axe des y
                fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
                palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
                label = TRUE,  # Affiche les étiquettes sur les barres
                lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
                lab.size = 2.5,  # Définit la taille des étiquettes
                lab.col = "white") +  # Définit la couleur des étiquettes
  theme(legend.position = "none")  # Supprime la légende du graphique

# Calcul des pourcentages pour Gender
Gen <- df %>%
  group_by(Gender, Exited) %>%  # Regroupe les données par 'Gender' et 'Exited'
  summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Gender' et 'Exited', puis supprime les groupes
  group_by(Gender) %>%  # Regroupe de nouveau par 'Gender'
  mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Gender'

# Crée un graphique à barres pour les pourcentages par 'Gender'
c2 <- ggbarplot(Gen, x = "Gender", y = "pourcentage",  # Définit 'Gender' comme l'axe des x et 'pourcentage' comme l'axe des y
                fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
                palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
                label = TRUE,  # Affiche les étiquettes sur les barres
                lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
                lab.size = 2.5,  # Définit la taille des étiquettes
                lab.col = "white") +  # Définit la couleur des étiquettes
  theme(legend.position = "none")  # Supprime la légende du graphique

# Calcul des pourcentages pour HasCrCard
HCrCard <- df %>%
  group_by(HasCrCard, Exited) %>%  # Regroupe les données par 'HasCrCard' et 'Exited'
  summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'HasCrCard' et 'Exited', puis supprime les groupes
  group_by(HasCrCard) %>%  # Regroupe de nouveau par 'HasCrCard'
  mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'HasCrCard'

# Crée un graphique à barres pour les pourcentages par 'HasCrCard'
c3 <- ggbarplot(HCrCard, x = "HasCrCard", y = "pourcentage",  # Définit 'HasCrCard' comme l'axe des x et 'pourcentage' comme l'axe des y
                fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
                palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
                label = TRUE,  # Affiche les étiquettes sur les barres
                lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
                lab.size = 2.5,  # Définit la taille des étiquettes
                lab.col = "white") +  # Définit la couleur des étiquettes
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 90, hjust = 1))  # Supprime la légende du graphique

# Calcul des pourcentages pour IsActiveMember
IsActMember <- df %>%
  group_by(IsActiveMember, Exited) %>%  # Regroupe les données par 'IsActiveMember' et 'Exited'
  summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'IsActiveMember' et 'Exited', puis supprime les groupes
  group_by(IsActiveMember) %>%  # Regroupe de nouveau par 'IsActiveMember'
  mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'IsActiveMember'

# Crée un graphique à barres pour les pourcentages par 'IsActiveMember'
c4 <- ggbarplot(IsActMember, x = "IsActiveMember", y = "pourcentage",  # Définit 'IsActiveMember' comme l'axe des x et 'pourcentage' comme l'axe des y
                fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
                palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
                label = TRUE,  # Affiche les étiquettes sur les barres
                lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
                lab.size = 2.5,  # Définit la taille des étiquettes
                lab.col = "white") +  # Définit la couleur des étiquettes
  theme(legend.position = "none")  # Supprime la légende du graphique

# Calcul des pourcentages pour Tenure
Ten <- df %>%
  group_by(Tenure, Exited) %>%  # Regroupe les données par 'Tenure' et 'Exited'
  summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Tenure' et 'Exited', puis supprime les groupes
  group_by(Tenure) %>%  # Regroupe de nouveau par 'Tenure'
  mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Tenure'

# Crée un graphique à barres pour les pourcentages par 'Tenure'
c5 <- ggbarplot(Ten, x = "Tenure", y = "pourcentage",  # Définit 'Tenure' comme l'axe des x et 'pourcentage' comme l'axe des y
                fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
                palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
                label = TRUE,  # Affiche les étiquettes sur les barres
                lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
                lab.size = 2.5,  # Définit la taille des étiquettes
                lab.col = "white") +  # Définit la couleur des étiquettes
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 90, hjust = 1))  # Supprime la légende du graphique

# Calcul des pourcentages pour Complain
Complain <- df %>%
  group_by(Complain, Exited) %>%  # Regroupe les données par 'Complain' et 'Exited'
  summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Complain' et 'Exited', puis supprime les groupes
  group_by(Complain) %>%  # Regroupe de nouveau par 'Complain'
  mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Complain'

# Crée un graphique à barres pour les pourcentages par 'Complain'
c6 <- ggbarplot(Complain, x = "Complain", y = "pourcentage",  # Définit 'Complain' comme l'axe des x et 'pourcentage' comme l'axe des y
                fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
                palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
                label = TRUE,  # Affiche les étiquettes sur les barres
                lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
                lab.size = 2.5,  # Définit la taille des étiquettes
                lab.col = "white") +  # Définit la couleur des étiquettes
  theme(legend.position = "none")  # Supprime la légende du graphique

# Calcul des pourcentages pour Card.Type
Card.Type <- df %>%
  group_by(Card.Type, Exited) %>%  # Regroupe les données par 'Card.Type' et 'Exited'
  summarise(Count = n(), .groups = "drop") %>%  # Compte les lignes pour chaque combinaison de 'Card.Type' et 'Exited', puis supprime les groupes
  group_by(Card.Type) %>%  # Regroupe de nouveau par 'Card.Type'
  mutate(pourcentage = round(Count / sum(Count) * 100))  # Calcule le pourcentage pour chaque groupe 'Card.Type'

# Crée un graphique à barres pour les pourcentages par 'Card.Type'
c7 <- ggbarplot(Card.Type, x = "Card.Type", y = "pourcentage",  # Définit 'Card.Type' comme l'axe des x et 'pourcentage' comme l'axe des y
                fill = "Exited", color = "Exited",  # Remplit les barres avec la couleur basée sur 'Exited' et définit la couleur des contours des barres
                palette = "Paired",  # Utilise la palette de couleurs "Paired" pour les barres
                label = TRUE,  # Affiche les étiquettes sur les barres
                lab.pos = "in",  # Positionne les étiquettes à l'intérieur des barres
                lab.size = 2.5,  # Définit la taille des étiquettes
                lab.col = "white") +  # Définit la couleur des étiquettes
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 90, hjust = 1))  # Supprime la légende du graphique





```
Afficher
```{r}
# Combine les graphiques créés précédemment en une seule image avec plusieurs sous-graphiques
ggarrange(c1, c2, c3, c4, c5, c6, c7,  # Les graphiques à combiner
          labels = "AUTO",  # Ajoute automatiquement des labels pour chaque graphique
          common.legend = T,  # Affiche une légende commune pour tous les graphiques
          legend = "bottom",  # Place la légende en bas de l'image combinée
          align = "hv",  # Aligne les graphiques horizontalement et verticalement
          ncol = 2)  # Dispose les graphiques en 2 colonnes

```



  *Parmi les 3 pays ayant des clients dans la banque, les clients allemands sont ceux qui abandonnent le plus, tandis que les 2 pays restants ont un taux d'abandon similaire dans les deux cas.*

  *Parmi les clients, plus de femmes partent que d’hommes, avec peu de différence.*

  *Les abandons sont similaires entre les clients qui possèdent une carte et ceux qui n’en ont pas.*

  *Il existe une double différence significative dans le taux de désabonnement entre les clients qui ne sont pas des membres actifs et ceux qui le sont.*
  
  *Le taux d’abandon des clients, compte tenu du nombre d’années passées dans la banque en tant que client, est similaire dans tous les cas quel que soit le nombre d’années d’ancienneté.*
  
  *Presque tous les client ayant depose une plainte quittent la banque alors que ceux qui n'en ont pas y restent*
  
  *Le taux d’abandon des clients, compte tenu du type de carte, est similaire dans tous les cas quel que soit le type de carte.*


    

```{r}
str(df)
```





# -----------------------------------------------------------------------------------------
## Partie IV : **Implémenter une Analyse Factorielle(ACP) **
# -----------------------------------------------------------------------------------------


Selectionner les variables numeriques pour faire l'ACP
```{r}
# Sélectionne uniquement les colonnes numériques du dataframe 'df'
# Utilise la fonction 'select_if' pour filtrer les colonnes en fonction de leur type
data_numeric <- df %>%
  select_if(is.numeric)  # 'is.numeric' vérifie si chaque colonne est de type numérique

# Affiche le dataframe contenant uniquement les colonnes numériques
data_numeric

```


Standardisation des variables numeriques
```{r}

df_scaled <- scale(data_numeric)

```

Réalisation de l'ACP
```{r}

# Effectue une analyse en composantes principales (ACP) sur les données normalisées
res.pca = PCA(df_scaled,                # Applique l'ACP sur le dataframe 'df_scaled'
              scale.unit=TRUE,          # Normalise les variables pour que chaque variable ait une variance de 1
              ncp=5,                   # Extrait les 5 premières composantes principales
              graph=T                  # Affiche un graphique des résultats de l'ACP
              )
```




Effectuer l'ACP en incluant Complain comme variable supplémentaire qualitative
```{r}
# Fusionner les deux dataframes
data_complete <- cbind(df_scaled, Complain = df$Complain)

# Effectuer l'ACP en incluant Complain comme variable supplémentaire qualitative
res.pca <- PCA(data_complete, scale.unit=TRUE, ncp=5, quali.sup=c(ncol(data_complete)), graph=T)

```
Coloration
```{r}
plot.PCA(res.pca, axes=c(1, 2), choix="ind", habillage=3)
```
*L'ACP réalisée montre comment les variables du jeu de données se comportent et se regroupent selon les deux premières dimensions principales :*

  *Interprétation du Graphe  des variables*

  Le graphique montre la projection des variables sur les deux premières dimensions de l'Analyse en Composantes Principales (ACP).

  *Dim 1 (18,7%) :*
      Positivement corrélée avec Balance, indiquant que cette variable contribue de manière significative à cette dimension.
        Négativement corrélée avec NumOfProducts, ce qui signifie que les clients avec un solde élevé tendent à avoir un nombre de produits faible, et inversement.

  *Dim 2 (14,8%) :*
      Négativement corrélée avec Satisfaction.Score, suggérant que les clients moins satisfaits ont tendance à être positionnés sur des valeurs négatives de Dim 2.
      Age est également faiblement corrélée négativement avec Dim 2, indiquant une légère tendance pour les clients plus âgés à se situer sur des valeurs négatives de cette dimension.

 *Variables modérément corrélées :*
      CreditScore, EstimatedSalary, et Point.Earned montrent des contributions faibles à modérées sur les deux dimensions, avec des angles faibles entre CreditScore et Point.Earned, suggérant une corrélation positive entre elles. Cependant, ces variables ne dominent aucune des dimensions.

  *Variables faiblement corrélées :*
      La variable Age est très faiblement corrélée avec les deux axes, ce qui signifie qu’elle n’apporte presque aucune information sur ces deux premières dimensions de l'ACP.
  
  
  
  **-----------------------------------------------------**
  
  
  *Interprétation du Graphique  des Individus*
  
  Le graphe des individus représente la projection des clients dans le plan formé par les deux premières dimensions de l'Analyse en Composantes Principales (ACP). Ces deux dimensions expliquent respectivement 18,70% et 14,89% de la variance totale des données, ce qui signifie qu'une part significative de l'information est capturée par ce graphique.

  *Répartition des Clients :* Les individus (clients) sont dispersés de manière relativement homogène autour de l'origine, ce qui suggère une diversité dans les comportements des clients en termes de variables analysées.

  *Couleur et Balance :* Les points colorés selon la variable Balance montrent que les clients avec un solde élevé (rouge) tendent à se concentrer sur la droite du graphe, tandis que ceux avec un solde faible (bleu) se trouvent plutôt sur la gauche. Cela indique que la dimension 1 est probablement influencée par la variable Balance.

  *Variable Supplémentaire - Complain :* La variable Complain, qui est binaire (Oui/Non), est représentée au centre du graphique. Cela signifie que les individus ayant déposé une plainte (Complain = Oui) ou non (Complain = Non) ne montrent pas de séparation claire sur les deux premières dimensions principales. Autrement dit, le fait de déposer une plainte ne semble pas être fortement associé aux dimensions principales capturées par l'ACP.









# -----------------------------------------------------------------------------------------
## Partie V : **Mise en œuvre d'un Algorithme d'Apprentissage**
# -----------------------------------------------------------------------------------------

```{r}
```
  *On voit que les variables initiales contiennent des informations pertinentes que l'ACP n'arrive pas à capturer de manière compacte*
  
  *les premières composantes principales n'expliquent qu'une faible proportion de la variance totale des données 34,51% (moins de 50%), cela signifie que l'ACP n'est pas très efficace pour résumer les données dans un espace de faible dimension. On va preferer, revenir aux données d'origine(Avant l'ACP) pour l'entraînement du modèle*





### Logistic Regression 


```{r}
# df$Tenure <- NULL


```

Divisez les données en sous-ensembles d'entrainement  et de test
```{r}


# Crée une partition aléatoire des données pour l'ensemble d'entraînement et de test
intrain <- createDataPartition(df$Exited,   # Variable pour partitionner les données (ici, 'Exited')
                               p = 0.7,       # Proportion des données utilisées pour l'entraînement (70%)
                               list = FALSE)  # Retourne un vecteur des indices, pas une liste

# Définit une graine aléatoire pour assurer la reproductibilité des résultats
set.seed(2024)  

# Crée l'ensemble d'entraînement en sélectionnant les lignes correspondant aux indices de 'intrain'
training <- df[intrain,]  

# Crée l'ensemble de test en sélectionnant les lignes qui ne sont pas dans 'intrain'
testing <- df[-intrain,]  

# Affiche les dimensions de l'ensemble d'entraînement et de l'ensemble de test
dim(training)   # Affiche le nombre de lignes et de colonnes de l'ensemble d'entraînement
dim(testing)    # Affiche le nombre de lignes et de colonnes de l'ensemble de test



```

 Vérifiez si le processus de division est correct
```{r}

# pour les donnees d'entrainnement
prop.table(table(training$Exited))

```

```{r}
# pour les donnees de test

prop.table(table(testing$Exited))


```

Crée un modèle de régression logistique
```{r}


LogModel <- glm(Exited ~ .,                # Formule du modèle : 'Exited' est la variable cible, '.' signifie toutes les autres variables comme prédicteurs
                family = binomial(link = "logit"),  # Spécifie que le modèle est une régression logistique avec la fonction de lien 'logit'
                data = training)        # Utilise l'ensemble de données d'entraînement pour ajuster le modèle

# Affiche le résumé du modèle pour voir les coefficients, les statistiques de significativité, etc.
print(summary(LogModel))    # Résumé du modèle affichant les détails sur les variables, les coefficients, les p-values, etc.

```
**Variables Significatives**
  *ComplainPlainte : Cette variable a le coefficient le plus élevé (13.59) et est hautement significative (p < 0.001). Cela indique que les clients ayant déposé une plainte sont beaucoup plus susceptibles de quitter la banque.*
  *Age : Le coefficient (0.111) est également significatif (p = 0.0298), ce qui suggère que l'âge est positivement associé à la probabilité de quitter la banque.*
  *IsActiveMemberActif : Avec un coefficient de -2.477 et une p-value de 0.0359, cette variable montre que les membres actifs sont moins susceptibles de quitter la banque.*



```{r}
# Convertit la variable 'Exited' dans l'ensemble de données de test en type caractère
testing$Exited <- as.character(testing$Exited)   # Transforme 'Exited' en chaîne de caractères pour pouvoir modifier les valeurs

# Remplace les valeurs "Resté" par "0" dans la variable 'Exited'
testing$Exited[testing$Exited == "Resté"] <- "0"   # Remplace toutes les occurrences de "Resté" par "0"

# Remplace les valeurs "Quitté" par "1" dans la variable 'Exited'
testing$Exited[testing$Exited == "Quitté"] <- "1"   # Remplace toutes les occurrences de "Quitté" par "1"

# Prédit les probabilités de sortie à l'aide du modèle logistique
fitted.results <- predict(LogModel,                   # Utilise le modèle LogModel pour faire des prédictions
                          newdata = testing,          # Prédictions sur les données de test
                          type = 'response')         # Type de prédiction : 'response' donne des probabilités

# Sélectionne aléatoirement 6 observations pour vérifier leurs probabilités prédites
set.seed(2024)  # Assure la reproductibilité de l'échantillonnage aléatoire
random_indices <- sample(1:nrow(testing), 6)  # Sélectionne 6 indices aléatoires
selected_results <- fitted.results[random_indices]  # Récupère les probabilités pour ces indices
selected_results  # Affiche les probabilités des 6 observations sélectionnées

# Optionnel : Affiche également les valeurs réelles correspondantes pour comparaison
selected_actual <- testing$Exited[random_indices]
data.frame(Probabilities = selected_results, Actual = selected_actual)

# Convertit les probabilités en classes binaires en utilisant un seuil de 0.5
fitted.results <- ifelse(fitted.results > 0.5, 1, 0)  # Si la probabilité est > 0.5, prédiction = 1 (Quitté), sinon 0 (Resté)

# Calcule l'erreur de classification en comparant les prédictions avec les valeurs réelles
misClasificError <- mean(fitted.results != testing$Exited)  # Moyenne des erreurs de classification

# Affiche l'exactitude du modèle de régression logistique
print(paste('Logistic Regression Accuracy', 1 - misClasificError))   # Affiche l'exactitude du modèle (1 - erreur de classification)

# Affiche la matrice de confusion pour évaluer les performances du modèle
print("Confusion Matrix for Logistic Regression")   # Affiche un message pour indiquer que la matrice de confusion sera affichée
table(testing$Exited, fitted.results > 0.5)    # Crée une table croisée pour montrer les résultats réels vs prédits

```

*Prédictions :*
  Les probabilités prédites par le modèle montrent des valeurs proches de 0 ou 1, indiquant une bonne séparation entre les classes (clients qui restent vs. clients qui quittent).

*Exactitude du Modèle :*
  Le modèle a atteint une exactitude (accuracy) de 99.8%, ce qui signifie qu'il a correctement classé 99.8% des observations dans l'ensemble de test.

*Matrice de Confusion :*

  1202 vrais négatifs (clients restés correctement identifiés).
  
  294 vrais positifs (clients quittés correctement identifiés).
  
  2 faux positifs (clients prédits comme quittant alors qu'ils sont restés).
  
  1 faux négatif (client prédit comme resté alors qu'il a quitté).




**Points clés à retenir**

  *Le fait qu'un client ait ou non déposé une plainte était le facteur le plus important dans le taux de désabonnement.*
  
  *Les autres facteurs liés au taux de désabonnement comprenaient l'âge du client, la géographie,  et selon qu'il soit actif ou pas.*

  *Il est intéressant de noter qu'il ne semble pas y avoir de lien entre le taux de satisfaction du client ou la durée de l'engagement et le taux de désabonnement.*
  

**Mesures pratiques**

  *Étant donné qu'il existe peu de corrélation entre le taux de satisfaction du client et le taux de désabonnement, il serait bénéfique de réaliser des enquêtes plus approfondies auprès des clients pour évaluer leurs besoins, leurs préoccupations et leur satisfaction générale*.

  *Les clients sont beaucoup plus susceptibles de se désabonner s'ils ont déjà déposé une plainte. Cela peut signifier que leurs plaintes n'ont pas été résolues de manière adéquate. Pour fidéliser ces clients, nous devons évaluer les plaintes les plus courantes et nous assurer que les clients sont satisfaits des résolutions.*
  
```{r}

```





# -----------------------------------------------------------------------------------------
## **CONCLUSION**
# -----------------------------------------------------------------------------------------


*Ce projet a visé à prédire l'attrition des clients bancaires en utilisant un modèle de régression logistique. Voici les principaux résultats :*

  *Variables Clés : L'âge, les plaintes, et le statut d'activité sont les variables les plus influentes pour prédire l'attrition des clients.*
  *Performance du Modèle : Le modèle a atteint une exactitude de 99.8% avec une très faible erreur de classification, indiquant une excellente capacité à identifier les clients à risque de départ.*
  *Insights : Les résultats fournissent des informations précieuses pour cibler les efforts de rétention.*

*Remarque : Bien que performant, le modèle doit être régulièrement mis à jour pour refléter les évolutions du comportement des clients et du marché.*

# Références
- [Source 1](https://github.com/Pendopr/Telecom_Churn_Classification/tree/main)
- [Source 2](https://jeffreyohene.github.io/projects/data/customer_churn.html)
- [Source 3](https://openclassrooms.com/fr/courses/8248096-initiez-vous-a-r-pour-lanalyse-de-donnees)


